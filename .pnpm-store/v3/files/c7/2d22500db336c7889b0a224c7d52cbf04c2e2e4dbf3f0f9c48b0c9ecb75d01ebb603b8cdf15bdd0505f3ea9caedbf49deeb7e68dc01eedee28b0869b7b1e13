"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const core_loggers_1 = require("@pnpm/core-loggers");
const logger_1 = __importDefault(require("@pnpm/logger"));
const path_absolute_1 = __importDefault(require("path-absolute"));
const requirePnpmfile_1 = __importDefault(require("./requirePnpmfile"));
function requireHooks(prefix, opts) {
    const globalPnpmfile = opts.globalPnpmfile && (0, requirePnpmfile_1.default)((0, path_absolute_1.default)(opts.globalPnpmfile, prefix), prefix);
    let globalHooks = globalPnpmfile?.hooks;
    const pnpmFile = opts.pnpmfile && (0, requirePnpmfile_1.default)((0, path_absolute_1.default)(opts.pnpmfile, prefix), prefix) ||
        (0, requirePnpmfile_1.default)(path_1.default.join(prefix, '.pnpmfile.cjs'), prefix);
    let hooks = pnpmFile?.hooks;
    if (!globalHooks && !hooks)
        return {};
    globalHooks = globalHooks || {};
    hooks = hooks || {};
    const cookedHooks = {};
    if ((globalHooks.readPackage != null) || (hooks.readPackage != null)) {
        logger_1.default.info({
            message: 'readPackage hook is declared. Manifests of dependencies might get overridden',
            prefix,
        });
    }
    for (const hookName of ['readPackage', 'afterAllResolved']) {
        if (globalHooks[hookName] && hooks[hookName]) {
            const globalHookContext = createReadPackageHookContext(globalPnpmfile.filename, prefix, hookName);
            const localHookContext = createReadPackageHookContext(pnpmFile.filename, prefix, hookName);
            // the `arg` is a package manifest in case of readPackage() and a lockfile object in case of afterAllResolved()
            cookedHooks[hookName] = async (arg) => {
                return hooks[hookName](await globalHooks[hookName](arg, globalHookContext), localHookContext);
            };
        }
        else if (globalHooks[hookName]) {
            const globalHook = globalHooks[hookName];
            const context = createReadPackageHookContext(globalPnpmfile.filename, prefix, hookName);
            cookedHooks[hookName] = (pkg) => globalHook(pkg, context);
        }
        else if (hooks[hookName]) {
            const hook = hooks[hookName];
            const context = createReadPackageHookContext(pnpmFile.filename, prefix, hookName);
            cookedHooks[hookName] = (pkg) => hook(pkg, context);
        }
    }
    const globalFilterLog = globalHooks.filterLog;
    const filterLog = hooks.filterLog;
    if (globalFilterLog != null && filterLog != null) {
        cookedHooks.filterLog = (log) => globalFilterLog(log) && filterLog(log);
    }
    else {
        cookedHooks.filterLog = globalFilterLog ?? filterLog;
    }
    return cookedHooks;
}
exports.default = requireHooks;
function createReadPackageHookContext(calledFrom, prefix, hook) {
    return {
        log: (message) => core_loggers_1.hookLogger.debug({
            from: calledFrom,
            hook,
            message,
            prefix,
        }),
    };
}
//# sourceMappingURL=requireHooks.js.map