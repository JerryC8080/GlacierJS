"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const archy_1 = __importDefault(require("archy"));
const chalk_1 = __importDefault(require("chalk"));
const cli_columns_1 = __importDefault(require("cli-columns"));
function default_1(peerDependencyIssuesByProjects, opts) {
    const projects = {};
    for (const [projectId, { bad, missing, conflicts, intersections }] of Object.entries(peerDependencyIssuesByProjects)) {
        projects[projectId] = { dependencies: {}, peerIssues: [] };
        for (const [peerName, issues] of Object.entries(missing)) {
            if (!conflicts.includes(peerName) &&
                intersections[peerName] == null) {
                continue;
            }
            for (const issue of issues) {
                createTree(projects[projectId], issue.parents, `${chalk_1.default.red('✕ missing peer')} ${formatNameAndRange(peerName, issue.wantedRange)}`);
            }
        }
        for (const [peerName, issues] of Object.entries(bad)) {
            for (const issue of issues) {
                createTree(projects[projectId], issue.parents, formatUnmetPeerMessage({
                    peerName,
                    ...issue,
                }));
            }
        }
    }
    const cliColumnsOptions = {
        newline: '\n  ',
        width: (opts?.width ?? process.stdout.columns) - 2,
    };
    return Object.entries(projects)
        .filter(([, project]) => Object.keys(project.dependencies).length > 0)
        .sort(([projectKey1], [projectKey2]) => projectKey1.localeCompare(projectKey2))
        .map(([projectKey, project]) => {
        const summaries = [];
        const { conflicts, intersections } = peerDependencyIssuesByProjects[projectKey];
        if (conflicts.length) {
            summaries.push(chalk_1.default.red(`✕ Conflicting peer dependencies:\n  ${(0, cli_columns_1.default)(conflicts, cliColumnsOptions)}`));
        }
        if (Object.keys(intersections).length) {
            summaries.push(`Peer dependencies that should be installed:\n  ${(0, cli_columns_1.default)(Object.entries(intersections).map(([name, version]) => formatNameAndRange(name, version)), cliColumnsOptions)}`);
        }
        const title = chalk_1.default.white(projectKey);
        let summariesConcatenated = summaries.join('\n');
        if (summariesConcatenated) {
            summariesConcatenated += '\n';
        }
        return `${(0, archy_1.default)(toArchyData(title, project))}${summariesConcatenated}`;
    }).join('\n');
}
exports.default = default_1;
function formatUnmetPeerMessage({ foundVersion, peerName, wantedRange, resolvedFrom }) {
    const nameAndRange = formatNameAndRange(peerName, wantedRange);
    if (resolvedFrom && resolvedFrom.length > 0) {
        return `✕ unmet peer ${nameAndRange}: found ${foundVersion} in ${resolvedFrom[resolvedFrom.length - 1].name}`;
    }
    return `${chalk_1.default.yellowBright('✕ unmet peer')} ${nameAndRange}: found ${foundVersion}`;
}
function formatNameAndRange(name, range) {
    if (range.includes(' ') || range === '*') {
        return `${name}@"${range}"`;
    }
    return `${name}@${range}`;
}
function createTree(pkgNode, pkgs, issueText) {
    const [pkg, ...rest] = pkgs;
    if (!pkgNode.dependencies[pkg.name]) {
        pkgNode.dependencies[pkg.name] = { dependencies: {}, peerIssues: [] };
    }
    if (rest.length === 0) {
        pkgNode.dependencies[pkg.name].peerIssues.push(issueText);
        return;
    }
    createTree(pkgNode.dependencies[pkg.name], rest, issueText);
}
function toArchyData(depName, pkgNode) {
    const result = {
        label: depName,
        nodes: [],
    };
    for (const wantedPeer of pkgNode.peerIssues) {
        result.nodes.push(wantedPeer);
    }
    for (const [depName, node] of Object.entries(pkgNode.dependencies)) {
        result.nodes.push(toArchyData(depName, node));
    }
    return result;
}
//# sourceMappingURL=index.js.map