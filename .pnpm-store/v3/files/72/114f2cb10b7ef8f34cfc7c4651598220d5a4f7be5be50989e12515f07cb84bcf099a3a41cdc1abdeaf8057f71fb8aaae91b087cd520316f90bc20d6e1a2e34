"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const Rx = __importStar(require("rxjs"));
const operators_1 = require("rxjs/operators");
const chalk_1 = __importDefault(require("chalk"));
const pretty_ms_1 = __importDefault(require("pretty-ms"));
const strip_ansi_1 = __importDefault(require("strip-ansi"));
const constants_1 = require("../constants");
const formatPrefix_1 = __importStar(require("./utils/formatPrefix"));
const outputConstants_1 = require("./outputConstants");
const NODE_MODULES = `${path_1.default.sep}node_modules${path_1.default.sep}`;
// When streaming processes are spawned, use this color for prefix
const colorWheel = ['cyan', 'magenta', 'blue', 'yellow', 'green', 'red'];
const NUM_COLORS = colorWheel.length;
// Ever-increasing index ensures colors are always sequential
let currentColor = 0;
exports.default = (log$, opts) => {
    // When the reporter is not append-only, the length of output is limited
    // in order to reduce flickering
    if (opts.appendOnly) {
        let lifecycle$ = log$.lifecycle;
        if (opts.aggregateOutput) {
            lifecycle$ = lifecycle$.pipe(aggregateOutput);
        }
        const streamLifecycleOutput = createStreamLifecycleOutput(opts.cwd);
        return lifecycle$.pipe((0, operators_1.map)((log) => Rx.of({
            msg: streamLifecycleOutput(log),
        })));
    }
    const lifecycleMessages = {};
    const lifecycleStreamByDepPath = {};
    const lifecyclePushStream = new Rx.Subject();
    // TODO: handle promise of .forEach?!
    log$.lifecycle // eslint-disable-line
        .forEach((log) => {
        const key = `${log.stage}:${log.depPath}`;
        lifecycleMessages[key] = lifecycleMessages[key] || {
            collapsed: log.wd.includes(NODE_MODULES),
            output: [],
            startTime: process.hrtime(),
            status: formatIndentedStatus(chalk_1.default.magentaBright('Running...')),
        };
        const exit = typeof log['exitCode'] === 'number';
        let msg;
        if (lifecycleMessages[key].collapsed) {
            msg = renderCollapsedScriptOutput(log, lifecycleMessages[key], { cwd: opts.cwd, exit, maxWidth: opts.width });
        }
        else {
            msg = renderScriptOutput(log, lifecycleMessages[key], { cwd: opts.cwd, exit, maxWidth: opts.width });
        }
        if (exit) {
            delete lifecycleMessages[key];
        }
        if (!lifecycleStreamByDepPath[key]) {
            lifecycleStreamByDepPath[key] = new Rx.Subject();
            lifecyclePushStream.next(Rx.from(lifecycleStreamByDepPath[key]));
        }
        lifecycleStreamByDepPath[key].next({ msg });
        if (exit) {
            lifecycleStreamByDepPath[key].complete();
        }
    });
    return Rx.from(lifecyclePushStream);
};
function toNano(time) {
    return (time[0] + (time[1] / 1e9)) * 1e3;
}
function renderCollapsedScriptOutput(log, messageCache, opts) {
    messageCache.label = messageCache.label ??
        `${highlightLastFolder((0, formatPrefix_1.formatPrefixNoTrim)(opts.cwd, log.wd))}: Running ${log.stage} script`;
    if (!opts.exit) {
        updateMessageCache(log, messageCache, opts);
        return `${messageCache.label}...`;
    }
    const time = (0, pretty_ms_1.default)(toNano(process.hrtime(messageCache.startTime)));
    if (log['exitCode'] === 0) {
        return `${messageCache.label}, done in ${time}`;
    }
    if (log['optional'] === true) {
        return `${messageCache.label}, failed in ${time} (skipped as optional)`;
    }
    return `${messageCache.label}, failed in ${time}${constants_1.EOL}${renderScriptOutput(log, messageCache, opts)}`;
}
function renderScriptOutput(log, messageCache, opts) {
    updateMessageCache(log, messageCache, opts);
    if (opts.exit && log['exitCode'] !== 0) {
        return [
            messageCache.script,
            ...messageCache.output,
            messageCache.status,
        ].join(constants_1.EOL);
    }
    if (messageCache.output.length > 10) {
        return [
            messageCache.script,
            `[${messageCache.output.length - 10} lines collapsed]`,
            ...messageCache.output.slice(messageCache.output.length - 10),
            messageCache.status,
        ].join(constants_1.EOL);
    }
    return [
        messageCache.script,
        ...messageCache.output,
        messageCache.status,
    ].join(constants_1.EOL);
}
function updateMessageCache(log, messageCache, opts) {
    if (log['script']) {
        const prefix = `${(0, formatPrefix_1.default)(opts.cwd, log.wd)} ${(0, outputConstants_1.hlValue)(log.stage)}`;
        const maxLineWidth = opts.maxWidth - prefix.length - 2 + ANSI_ESCAPES_LENGTH_OF_PREFIX;
        messageCache.script = `${prefix}$ ${cutLine(log['script'], maxLineWidth)}`;
    }
    else if (opts.exit) {
        const time = (0, pretty_ms_1.default)(toNano(process.hrtime(messageCache.startTime)));
        if (log['exitCode'] === 0) {
            messageCache.status = formatIndentedStatus(chalk_1.default.magentaBright(`Done in ${time}`));
        }
        else {
            messageCache.status = formatIndentedStatus(chalk_1.default.red(`Failed in ${time}`));
        }
    }
    else {
        messageCache.output.push(formatIndentedOutput(opts.maxWidth, log));
    }
}
function formatIndentedStatus(status) {
    return `${chalk_1.default.magentaBright('└─')} ${status}`;
}
function highlightLastFolder(p) {
    const lastSlash = p.lastIndexOf('/') + 1;
    return `${chalk_1.default.gray(p.substr(0, lastSlash))}${p.substr(lastSlash)}`;
}
const ANSI_ESCAPES_LENGTH_OF_PREFIX = (0, outputConstants_1.hlValue)(' ').length - 1;
function createStreamLifecycleOutput(cwd) {
    currentColor = 0;
    const colorByPrefix = new Map();
    return streamLifecycleOutput.bind(null, colorByPrefix, cwd);
}
function streamLifecycleOutput(colorByPkg, cwd, logObj) {
    const prefix = formatLifecycleScriptPrefix(colorByPkg, cwd, logObj.wd, logObj.stage);
    if (typeof logObj['exitCode'] === 'number') {
        if (logObj['exitCode'] === 0) {
            return `${prefix}: Done`;
        }
        else {
            return `${prefix}: Failed`;
        }
    }
    if (logObj['script']) {
        return `${prefix}$ ${logObj['script']}`;
    }
    const line = formatLine(Infinity, logObj);
    return `${prefix}: ${line}`;
}
function formatIndentedOutput(maxWidth, logObj) {
    return `${chalk_1.default.magentaBright('│')} ${formatLine(maxWidth - 2, logObj)}`;
}
function formatLifecycleScriptPrefix(colorByPkg, cwd, wd, stage) {
    if (!colorByPkg.has(wd)) {
        const colorName = colorWheel[currentColor % NUM_COLORS];
        colorByPkg.set(wd, chalk_1.default[colorName]);
        currentColor += 1;
    }
    const color = colorByPkg.get(wd);
    return `${color((0, formatPrefix_1.default)(cwd, wd))} ${(0, outputConstants_1.hlValue)(stage)}`;
}
function formatLine(maxWidth, logObj) {
    const line = cutLine(logObj['line'], maxWidth);
    // TODO: strip only the non-color/style ansi escape codes
    if (logObj['stdio'] === 'stderr') {
        return chalk_1.default.gray(line);
    }
    return line;
}
function cutLine(line, maxLength) {
    return (0, strip_ansi_1.default)(line).substr(0, maxLength);
}
function aggregateOutput(source) {
    return source.pipe((0, operators_1.groupBy)(data => data.depPath), (0, operators_1.mergeMap)(group => {
        return group.pipe((0, operators_1.buffer)(group.pipe((0, operators_1.filter)(msg => 'exitCode' in msg))));
    }), (0, operators_1.map)(ar => Rx.from(ar)), (0, operators_1.mergeAll)());
}
;
//# sourceMappingURL=reportLifecycleScripts.js.map